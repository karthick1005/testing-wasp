name: Deploy Apps to Coolify

on:
  push:
    branches:
      - apps-publish
    paths:
      - 'apps/**'
  workflow_dispatch:

env:
  DOCKER_REGISTRY: ghcr.io
  DOCKER_REGISTRY_USERNAME: ${{ github.repository_owner }}
  DOCKER_REGISTRY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
  NODE_VERSION: "18"
  COOLIFY_API_URL: "http://34.136.254.179:8000/api"  # Change to your Coolify API URL
  COOLIFY_TOKEN: ${{ secrets.COOLIFY_TOKEN }}
  PROJECT_ID: ${{ secrets.PROJECT_ID }}
  DEPLOYMENT: "production"

jobs:
  detect-changed-apps:
    runs-on: ubuntu-latest
    outputs:
      changed_apps: ${{ steps.set_changed_apps.outputs.apps }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed apps
        id: set_changed_apps
        run: |
          if [[ -z "${{ github.event.before }}" || "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]]; then
            git fetch --depth=2 origin main
            BASE_SHA=$(git rev-parse HEAD^)
          else
            BASE_SHA="${{ github.event.before }}"
          fi
          echo "BASE_SHA=$BASE_SHA"

          CHANGED_FILES=$(git diff --name-only $BASE_SHA ${{ github.sha }})

          echo "Changed files:"
          echo "$CHANGED_FILES"

          APPS_CHANGED=()
          for file in $CHANGED_FILES; do
            if [[ "$file" == apps/* ]]; then
              app_name=$(echo $file | cut -d/ -f2)
              APPS_CHANGED+=($app_name)
            fi
          done

          # Remove duplicates
          UNIQUE_APPS=($(echo "${APPS_CHANGED[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))

          echo "Apps changed: ${UNIQUE_APPS[@]}"

          # Convert to JSON array format
          if [ ${#UNIQUE_APPS[@]} -eq 0 ]; then
            echo "::set-output name=apps::[]"
          else
            APPS_JSON=$(printf '"%s",' "${UNIQUE_APPS[@]}")
            APPS_JSON="[${APPS_JSON%,}]"
            echo "::set-output name=apps::$APPS_JSON"
          fi

  deploy-apps:
    needs: detect-changed-apps
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: ${{ fromJSON(needs.detect-changed-apps.outputs.changed_apps) }}

    if: needs.detect-changed-apps.outputs.changed_apps != '[]'

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Ensure Coolify resource exists and is linked
        env:
          APP_NAME: ${{ matrix.app }}
          COOLIFY_API_URL: ${{ env.COOLIFY_API_URL }}
          COOLIFY_TOKEN: ${{ env.COOLIFY_TOKEN }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
          DEPLOYMENT: ${{ env.DEPLOYMENT }}
          SERVER_ID: ${{ secrets.SERVER_ID }}
        run: |
          project_uuid=${PROJECT_ID}
          server_uuid=${SERVER_ID}

          echo "Using project UUID: $PROJECT_ID"

          # echo "URL: $COOLIFY_API_URL/v1/projects/$project_uuid/$DEPLOYMENT"
          # echo "Token: $COOLIFY_TOKEN"
          # 3. Get application information  
          applications_response=$(curl -v -H "Authorization: Bearer $COOLIFY_TOKEN" "$COOLIFY_API_URL/v1/projects/$project_uuid/$DEPLOYMENT")
          echo "Full response from Coolify API:"
          # echo "$applications_response"
          application_uuid=$(echo "$applications_response" | jq -r '.uuid // empty')
          application_name=$(echo "$applications_response" | jq -r '.name // empty')


          if [ -z "$app_uuid" ]; then
            echo "Application not found for $APP_NAME, creating new Docker image application..."

            create_app_response=$(curl -s -X POST \
            -H "Authorization: Bearer $COOLIFY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{
              \"project_uuid\": \"$project_uuid\",
              \"server_uuid\": \"$server_uuid\",
              \"environment_name\": \"$DEPLOYMENT\",
              \"name\": \"$APP_NAME\",
              \"description\": \"Auto-generated application for $APP_NAME\",
              \"docker_registry_image_name\": \"ghcr.io/${{ github.repository_owner }}/$APP_NAME\",
              \"docker_registry_image_tag\": \"latest\",
              \"ports_exposes\": \"3000\",
              \"instant_deploy\": false
            }" \
            "$COOLIFY_API_URL/v1/applications/dockerimage")


            app_uuid=$(echo "$create_app_response" | jq -r '.uuid // .data.uuid // empty')

            if [ -z "$app_uuid" ]; then
              echo "Failed to create application for $APP_NAME"
              echo "Create application response: $create_app_response"
              exit 1
            fi

            echo "Created new application with UUID: $app_uuid"
          else
            echo "Found existing application with UUID: $app_uuid"
          fi
          echo "Using environment: $environment_name ($environment_uuid)"


          # 5. Check if application already exists
          echo "Checking for existing application $APP_NAME..."
          app_uuid=$(echo "$applications_response" | jq -r --arg name "$APP_NAME" '.applications[] | select(.name == $name) | .uuid // empty')


          if [ -z "$app_uuid" ]; then
            echo "Application not found for $APP_NAME, creating new Docker image application..."
            
            # 6. Create Docker image application using the correct API
            create_app_response=$(curl -s -X POST \
              -H "Authorization: Bearer $COOLIFY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{
                \"project_uuid\": \"$project_uuid\",
                \"server_uuid\": \"$server_uuid\",
                \"environment_name\": \"$environment_name\",
                \"environment_uuid\": \"$environment_uuid\",
                \"destination_uuid\": \"$destination_uuid\",
                \"name\": \"$APP_NAME\",
                \"description\": \"Auto-generated application for $APP_NAME\",
                \"docker_registry_image_name\": \"ghcr.io/${{ github.repository_owner }}/$APP_NAME\",
                \"docker_registry_image_tag\": \"latest\",
                \"ports_exposes\": \"80\",
                \"instant_deploy\": false
              }" \
              "$COOLIFY_API_URL/v1/applications/dockerimage")
            
            app_uuid=$(echo "$create_app_response" | jq -r '.uuid // .data.uuid // empty')
            
            if [ -z "$app_uuid" ]; then
              echo "Failed to create application for $APP_NAME"
              echo "Create application response: $create_app_response"
              exit 1
            fi
            
            echo "Created new application with UUID: $app_uuid"
          else
            echo "Found existing application with UUID: $app_uuid"
          fi

          # 3. The application should be ready for deployment
          echo "Application $APP_NAME is ready for deployment with UUID: $app_uuid"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Log in to Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ env.DOCKER_REGISTRY_USERNAME }}
          password: ${{ env.DOCKER_REGISTRY_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate Dockerfile for app
        env:
          APP_NAME: ${{ matrix.app }}
        run: |
          APP_DIR="./apps/$APP_NAME"
          
          echo "Generating Dockerfile for $APP_NAME in $APP_DIR"
          
          # Create Dockerfile
          cat > "$APP_DIR/Dockerfile" << 'EOF'
          # Use Node.js 18 as base image
          FROM node:18-alpine AS build
          
          # Set working directory
          WORKDIR /app
          
          # Copy package files
          COPY package*.json ./
          
          # Install dependencies
          RUN npm ci --only=production
          
          # Copy source code
          COPY . .
          
          # Build the application
          RUN npm run build
          
          # Production stage
          FROM nginx:alpine
          
          # Copy built assets from build stage
          COPY --from=build /app/dist /usr/share/nginx/html
          
          # Copy nginx configuration
          COPY nginx.conf /etc/nginx/nginx.conf
          
          # Expose port 80
          EXPOSE 80
          
          # Start nginx
          CMD ["nginx", "-g", "daemon off;"]
          EOF
          
          # Create nginx.conf
          cat > "$APP_DIR/nginx.conf" << 'EOF'
          events {
              worker_connections 1024;
          }
          
          http {
              include       /etc/nginx/mime.types;
              default_type  application/octet-stream;
          
              # Enable gzip compression
              gzip on;
              gzip_vary on;
              gzip_min_length 1024;
              gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;
          
              server {
                  listen 80;
                  server_name localhost;
                  root /usr/share/nginx/html;
                  index index.html;
          
                  # Enable CORS for Module Federation
                  add_header 'Access-Control-Allow-Origin' '*' always;
                  add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, PATCH, OPTIONS' always;
                  add_header 'Access-Control-Allow-Headers' 'X-Requested-With, content-type, Authorization' always;
          
                  # Handle preflight requests
                  if ($request_method = 'OPTIONS') {
                      add_header 'Access-Control-Allow-Origin' '*';
                      add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, PATCH, OPTIONS';
                      add_header 'Access-Control-Allow-Headers' 'X-Requested-With, content-type, Authorization';
                      add_header 'Access-Control-Max-Age' 1728000;
                      add_header 'Content-Type' 'text/plain; charset=utf-8';
                      add_header 'Content-Length' 0;
                      return 204;
                  }
          
                  # Serve static files
                  location / {
                      try_files $uri $uri/ /index.html;
                      
                      # Cache static assets
                      location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
                          expires 1y;
                          add_header Cache-Control "public, immutable";
                      }
                  }
          
                  # Special handling for Module Federation remote entry
                  location /remoteEntry.js {
                      add_header 'Access-Control-Allow-Origin' '*' always;
                      add_header 'Cache-Control' 'no-cache, no-store, must-revalidate' always;
                      add_header 'Pragma' 'no-cache' always;
                      add_header 'Expires' '0' always;
                  }
          
                  # Health check endpoint
                  location /health {
                      access_log off;
                      return 200 "OK\n";
                      add_header Content-Type text/plain;
                  }
              }
          }
          EOF
          
          # Create .dockerignore
          cat > "$APP_DIR/.dockerignore" << 'EOF'
          node_modules
          npm-debug.log
          .git
          .gitignore
          README.md
          FIXES.md
          NAVBAR_FIX.md
          ROUTING_GUIDE.md
          .env
          .env.local
          .env.development.local
          .env.test.local
          .env.production.local
          dist
          build
          coverage
          .nyc_output
          EOF
          
          echo "Generated Dockerfile, nginx.conf, and .dockerignore for $APP_NAME"

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REGISTRY_USERNAME }}/${{ matrix.app }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ./apps/${{ matrix.app }}
          file: ./apps/${{ matrix.app }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Trigger Coolify deployment
        env:
          COOLIFY_API_URL: ${{ env.COOLIFY_API_URL }}
          COOLIFY_TOKEN: ${{ env.COOLIFY_TOKEN }}
          APP_NAME: ${{ matrix.app }}
        run: |
          echo "Triggering deployment for $APP_NAME"
          
          # Get project UUID
          projects_response=$(curl -s -H "Authorization: Bearer $COOLIFY_TOKEN" "$COOLIFY_API_URL/v1/projects")
          project_uuid=$(echo "$projects_response" | jq -r '.data[0].uuid // empty')
          
          if [ -z "$project_uuid" ]; then
            echo "Project UUID not found, cannot trigger deployment."
            exit 1
          fi
          
          # Get application UUID
          applications_response=$(curl -s -H "Authorization: Bearer $COOLIFY_TOKEN" "$COOLIFY_API_URL/v1/projects/$project_uuid/applications")
          app_uuid=$(echo "$applications_response" | jq -r --arg name "$APP_NAME" '.data[] | select(.name == $name) | .uuid // empty')

          if [ -z "$app_uuid" ]; then
            echo "Application UUID not found for $APP_NAME, cannot trigger deployment."
            exit 1
          fi

          # Trigger deployment using Coolify v1 API
          deploy_response=$(curl -s -X POST \
            -H "Authorization: Bearer $COOLIFY_TOKEN" \
            -H "Content-Type: application/json" \
            "$COOLIFY_API_URL/v1/applications/$app_uuid/deploy")
          
          echo "Deploy response: $deploy_response"
